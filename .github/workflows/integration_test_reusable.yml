name: integration-tests

on:
  workflow_call:
    inputs:
      ref:
        description: "Git ref to checkout"
        required: true
        type: string

env:
  PYTHON_VERSION: "3.10.12"
  MINIKUBE_VERSION: "v1.34.0"
  KUBECTL_VERSION: "v1.31.1"
  KUBERNETES_VERSION: "v1.31.0"
  GCP_PROJECT_ID: "clocus-ai-dev"
  GCP_SERVICE_ACCOUNT: "rag-docs@clocus-ai-dev.iam.gserviceaccount.com"
  GCP_WORKLOAD_IDENTITY_PROVIDER: "projects/110921468278/locations/global/workloadIdentityPools/github-actions-pool/providers/github-provider"

jobs:
  integration-tests:
    name: Run Integration Tests
    runs-on: ubuntu-latest
    timeout-minutes: 20

    # Required for Workload Identity Federation
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref }}

      - name: Authenticate to Google Cloud
        id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}

      - name: Get secrets from Secret Manager
        id: secrets
        uses: google-github-actions/get-secretmanager-secrets@v2
        with:
          secrets: |-
            OPENAI_API_KEY:projects/${{ env.GCP_PROJECT_ID }}/secrets/openai-api-key/versions/latest
            COHERE_API_KEY:projects/${{ env.GCP_PROJECT_ID }}/secrets/cohere-api-key/versions/latest

      - name: Setup Minikube
        uses: manusa/actions-setup-minikube@v2.13.0
        with:
          minikube version: ${{ env.MINIKUBE_VERSION }}
          kubernetes version: ${{ env.KUBERNETES_VERSION }}
          github token: ${{ secrets.GITHUB_TOKEN }}
          driver: docker
          start args: "--cpus 2 --memory 4096"

      - name: Verify Minikube
        run: |
          minikube status
          kubectl version --client
          kubectl config use-context minikube
          kubectl get nodes -o wide
          kubectl wait --for=condition=ready node --all --timeout=300s

      - name: Setup Skaffold
        run: |
          curl -Lo skaffold https://storage.googleapis.com/skaffold/releases/v2.16.1/skaffold-linux-amd64
          chmod +x skaffold
          sudo mv skaffold /usr/local/bin/
          skaffold version

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Set up uv
        uses: astral-sh/setup-uv@v5
        with:
          enable-cache: true
          cache-dependency-glob: "backend/uv.lock"

      - name: Install Python dependencies
        working-directory: ./backend
        run: uv sync --extra integration

      - name: Prepare .env files for Docker build
        run: |
          echo "Creating .env files from templates..."
          cp backend/backend.env.template backend/backend.env
          cp frontend/frontend.env.template frontend/frontend.env

      - name: Build Docker images
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          echo "Building images with tag: ${IMAGE_TAG}"

          # Point Docker CLI to Minikube's Docker daemon
          eval $(minikube -p minikube docker-env)

          # Build images directly in Minikube
          docker build -t chromadb-init:${IMAGE_TAG} -f k8s/base/vectordb/Dockerfile k8s/base/vectordb/
          docker build -t rag-docs-backend:${IMAGE_TAG} -f backend/Dockerfile backend
          docker build -t rag-docs-frontend:${IMAGE_TAG} -f frontend/Dockerfile frontend

          # Verify images
          docker images | grep ${IMAGE_TAG}

      - name: Create Kubernetes secrets
        env:
          OPENAI_API_KEY: ${{ steps.secrets.outputs.OPENAI_API_KEY }}
          COHERE_API_KEY: ${{ steps.secrets.outputs.COHERE_API_KEY }}
        run: |
          kubectl create secret generic api-keys \
            --from-literal=OPENAI_API_KEY="${OPENAI_API_KEY}" \
            --from-literal=COHERE_API_KEY="${COHERE_API_KEY}" \
            --namespace=default

      - name: Deploy with Skaffold
        env:
          IMAGE_TAG: ${{ github.sha }}
          CI: true
        run: |
          skaffold run -p ci --default-repo="" --tag=${IMAGE_TAG}

      - name: Wait for deployments to be ready
        run: |
          echo "Waiting for ChromaDB..."
          kubectl wait --for=condition=ready pod -l app=chromadb --timeout=100s

          echo "Waiting for Backend..."
          kubectl wait --for=condition=ready pod -l app=rag-docs-backend --timeout=100s

          echo "Waiting for Frontend..."
          kubectl wait --for=condition=ready pod -l app=rag-docs-frontend --timeout=100s

          kubectl get pods

      - name: Setup port forwarding
        run: |
          echo "Setting up port forwarding..."
          kubectl port-forward svc/rag-docs-backend 8106:8106 &
          kubectl port-forward svc/chromadb 9001:8000 &
          sleep 10

          # Verify port forwards
          curl -f --max-time 10 http://localhost:8106/health || (echo "Backend health check failed" && exit 1)
          curl -f --max-time 10 http://localhost:9001/api/v2/heartbeat || (echo "ChromaDB health check failed" && exit 1)

      - name: Run Behave integration tests
        env:
          BACKEND_URL: http://localhost:8106
          CHROMADB_URL: http://localhost:9001
        run: |
          cd backend/tests/behave
          uv run behave --format=pretty --format=json --outfile=behave-results.json

      - name: Collect logs on failure
        if: failure()
        run: |
          mkdir -p logs

          # Get all pod names (last 500 lines only to save time)
          kubectl get pods -o name | while read pod; do
            pod_name=$(basename $pod)
            echo "Collecting logs for $pod_name"
            kubectl logs --tail=500 $pod_name > logs/${pod_name}.log 2>&1 || echo "Failed to get logs for $pod_name"
          done

          kubectl get events --sort-by='.lastTimestamp' > logs/events.log
          kubectl describe pods > logs/pod-descriptions.log

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: integration-test-results-${{ github.sha }}
          path: |
            backend/tests/behave/*.json
            logs/
          if-no-files-found: ignore

      - name: Cleanup
        if: always()
        run: |
          skaffold delete -p ci || true
          kubectl delete secret api-keys || true

      - name: Generate test summary
        if: always()
        run: |
          echo "## Integration Test Results" >> $GITHUB_STEP_SUMMARY
          if [ -f backend/tests/behave/behave-results.json ]; then
            echo "Test results available in artifacts" >> $GITHUB_STEP_SUMMARY
          fi
